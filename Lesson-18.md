## Коллекции и функции высших порядков

Функциональный стиль предлагает использовать стандартные рекурсивные паттерны в форме функций высших порядков.

Функции в стандартных библиотеках F# естественно соответствуют абстрактным понятиям и поддерживают высокоуровневое проектирование программ.

Списки, множества и отображения - это конечные коллекции (наборы значений, структурированные некоторым способом), запрограммированные в функциональном стиле.

Стандартные библиотеки F# содержат функции высших порядков для работы с основными структурами (типами) данных.

### 41. Списки

41.1. Функция map (отображение)

Функция высшего порядка List.map применяет функцию (первый параметр) к каждому элементу списка (второй параметр).

```
List.map f [ x1; x2; ...; xn ] = [ f(x1); f(x2); ...; f(xn) ]
```

Например:

```
(List.map int [1.1; 2.2; 3.3]) = [1; 2; 3] // true

let float2int = List.map int 

(float2int [1.1; 2.2; 3.3]) = [1; 2; 3] // true
```

41.2. Стандартные функции с предикатом для списков

В стандартной библиотеке F# есть немало функций, которые используют функцию-предикат типа `'a -> bool` применительно к спискам.

Функция List.exists возвращает true, если предикат, примененный ко всем элементам списка, хотя бы для одного элемента вернёт true.

```
List.exists (fun x -> x < 0) [1; 2; 3] // false
List.exists (fun x -> x < 0) [-1; 2; 3] // true
```

Функция List.forall возвращает true, если предикат, примененный ко всем элементам списка, для каждого элемента без исключения вернёт true.

```
List.forall (fun x -> x > 0) [1; 2; 3] // true
List.forall (fun x -> x > 0) [-1; 2; 3] // false
```

Функция List.tryFind возвращает Some x , если предикат, примененный ко всем элементам списка, для первого по порядку подходящего элемента x вернёт true, или None в противном случае.

```
(List.tryFind (fun x -> x > 0) [-1; 2; 3]) = Some 2 // true
(List.tryFind (fun x -> x < 0) [1; 2; 3]) = None // true
```

Функция фильтрации List.filter возвращает список тех элементов из исходного списка, для которых предикат истинен.

```
(List.filter (fun x -> x > 0) [-1; 2; 3]) = [2; 3]
```

41.3. Функции свёртки fold и foldBack

Функция List.fold применяет функцию (первый параметр), которая имеет два аргумента, к каждой паре значений списка (третий параметр), и результат "сжатия" списка объединяет со вторым параметром (начальным значением).

Если вместо функции-параметра представить диадический оператор, то он как бы вставляется между элементами списка.

```
let f x y = x + y
List.fold f 4 [1; 2; 3] // 10 = 4 + [1 + 2 + 3] = 4 + [ f( f(1,2) ,3 ) ]
```

Переворачивание списка задом наперёд:

```
let rev lst = List.fold (fun head tail -> tail::head) [] lst
(rev [1; 2; 3]) = [3; 2; 1] // true
```

Функция List.foldBack аналогична фунции fold с тем отличием, что порядок применения функции-параметра противоположный. Список следует вторым параметром, а начальное значение - третьим.

```
List.foldBack f [1; 2; 3] 4 // 10 = [1 + 2 + 3] + 4 = [ f(1, f(2,3)) ] + 4
```

Если функция-параметр некоммутативна, то результаты работы fold и foldBack могут быть разными.

```
let minus x y = x - y
List.foldBack minus [1; 2; 3] 0 = 2 // 2 = 1 - (2 - (3 - 0))
List.fold minus 0 [1; 2; 3] = -6 // -6 = ((0 - 1) - 2) - 3
```

В функциях fold и foldback допускается указание инфиксных операторов как префиксных.

```
List.foldBack (-) [1; 2; 3] 0
List.fold (+) 4 [1; 2; 3]
```

### 41.4. Задания

41.4.1. Напишите функцию `list_filter`, которая реализует стандартную функцию List.filter, с помощью List.foldBack.

41.4.2. Напишите функцию `sum(p, xs)`, где p - предикат int -> bool, и xs - список целых.
Функция возвращает сумму тех элементов xs, для которых предикат истинен.
Реализуйте sum с помощью List.fold или List.foldBack.

41.4.3. Напишите функцию revrev, которая получает на вход список списков, и перевёртывает как порядок вложенных списков, так и порядок элементов внутри каждого вложенного списка.

```
revrev [[1;2];[3;4;5]] = [[5;4;3];[2;1]]
```

Реализуйте revrev с помощью List.fold или List.foldBack.

Шаблон для отправки на сервер:

```
// 41.4.1
let list_filter f xs = ...

// 41.4.2
let sum (p, xs) = ...

// 41.4.3
let revrev = ...
```
