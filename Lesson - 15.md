
## Часть 4. Списки

### 30. Списки (lists)

Списки - это фундаментальный тип в функциональном программировании.

Список - это конечная последовательность значений одного типа.

Списки отличаются от кортежей тем, что представляют собой не одно целое, а цепочку однотипных значений, которую удобно обрабатывать агрегатными операторами.

Первый элемент списка называется голова, оставшаяся часть списка называется хвост.

Значения в списке заключаются в квадратные скобки и разделяются точкой с запятой.

```
[ 1; 2; 3; 4; 5 ]
[ "1, 2"; "3, 4, 5" ]
```

Список может состоять из списков с элементами одного типа.

```
[[2; 3]; [3]; [2; 3; 3]]
[["hi"]; ["how";"are"]; ["you"]; ["fine";"and";"you"]]
```

Тип списка - это тип элементов + list, например, int list или string list.

Элемент list в типе списка называется конструктор типа.

```
[ (1, "1"); (2, "2") ] // (int * string) list

type Animal = 
  | Cat of int
  | Dog of int
[ Cat 5; Dog 7 ] // Animal list

type Cat = {name: string; age: int}
[{name = "Barsik"; age = 5}] // Cat list

let f1 n = n + n
let f2 n = n * n
[ f1; f2 ] // ('a -> 'b) list
```

Символ ' обозначает, что может использоваться обобщённый параметр (значение любого типа).

### 31. Сравнение списков

Списки считаются равными, если совпадают их длины и равны все элементы, соответствующие друг другу по позициям в списке.

```
[1; 2; 3] = [1; 2; 3] // true
[1; 2; 3] = [1; 3; 2] // false
```

Сравнение списков разного типа и списков, содержащих функции, вызовет ошибку компиляции.

```
[1; 2; 3] = ['1'; '2'; '3'] // ошибка компиляции
```

Если список является правильным префиксом другого списка, то он считается меньшим.

```
[1; 2] < [1; 2; 3] // true
```

Если первые n элементов двух списков совпадают, то результатом их сравнения будет результат сравнения двух следующих элементов с индексами n+1 :

```
[1; 2; 2; 128] > [1; 2; 3] // false
```

Стандартная функция compare может применяться и к спискам:

```
compare [1; 2; 2; 128] [1; 2; 3] // -1
```

## Базовые действия над списками

### 32. Добавление элемента в голову

Оператор :: (cons) добавляет левый аргумент к списку - правому аргументу.

```
1 :: [2; 3; 4; 5] = [1; 2; 3; 4; 5] // true
"" :: [] = [""] // true
```

Ассоциация cons правая.

```
"1" :: "2" :: ["3"] = "1" :: ("2" :: ["3"]) // true
```

### 33. Сопоставление с шаблоном

Оператор cons может использоваться при создании шаблонов списков.

```
let x_head :: x_list = [1; 2; 3]
x_head = 1 // true
x_list = [2; 3] // true

let [x1; x2; x3] = [1; 2; 3]
x1 = 1 && x2 = 2 && x3 = 3 // true

let x1 :: x2 :: x3 = [1; 2; 3; 4]
x1 = 1 && x2 = 2 && x3 = [3; 4] // true

let (x1,x2) :: x3 = [ (1,2); (3,4)]
x1 = 1 && x2 = 2 && x3 = [(3, 4)] // true
```

### 34. Задания

34.1. Напишите функцию upto: int -> int list, которая работает так:
```
upto n = [1; 2; ...; n].
```

34.2. Напишите функцию dnto: int -> int list, которая работает так:

```
downto n = [n; n-1; n-2; ...; 1].
```

34.3. Напишите функцию evenn: int -> int list, которая генерирует список из первых n неотрицательных чётных чисел.

Шаблон для отправки на сервер:

```
// 34.1
let rec upto = ...

// 34.2
let rec dnto = ...

// 34.3
let rec evenn = ...
```
