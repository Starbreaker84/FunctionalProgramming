## Модули, ООП и императивный стиль

### 44. Модули

#### 44.1. Абстракция

Ключевая концепция проектирования хорошей библиотеки - это абстракция.

Абстракция говорит, что пользователь может делать, но скрывает от него, как это делается.

Абстракция на семантическом уровне описывается с помощью
1) интерфейса, задающегося набором типов,
2) реализации, состоящей из значений, функций, вычислений.

Модуль - это удобное средство для создания абстракций и объединения логически связанных элементов программы в одно целое.

Модуль задаётся ключевым словом module в начале файла, и следующим за ним названием модуля.
```
module Test1
```
#### 44.2. Релизация модуля

На синтаксическом уровне абстракция модуля задаётся спецификациями.
```
type имя-типа ...
val имя = тип
```
Эта часть называется сигнатурой модуля.

Можно указывать только одно имя типа, скрывая его реализацию.
```
type имя-типа
```
Модули могут состоять из нескольких файлов; компилируются модули в библиотеки.

Первый файл модуля с расширением .fsi содержит сигнатуру модуля (спецификация интерфейса), а другие, с исходным кодом, содержат реализацию модуля.

Сущности, объявленные только в реализации модуля, недоступны пользователям библиотеки.

#### 44.3. Пример модуля

Создаётся модуль с определением двумерной точки Point, состоящей из двух вещественных значений x и y.

Реализация модуля:
```
module Point

type Point = P of float * float

let create (x,y) = P(x,y)
let (.+.) (P(x1,y1)) (P(x2,y2)) = P(x1+x2,y1+y2)
let getx (P(x1,y1)) = x1
let gety (P(x1,y1)) = y1
```
Сигнатура модуля:
```
module Point

type Point

val create : float * float -> Point
val (.+.) : Point -> Point -> Point
val getx : Point -> float
val gety : Point -> float
```
Для обращения к элементам модуля надо указать его название после ключевого слова open.

Использование модуля:
```
open Point
let p1 = create(1.0, 1.0)
let p2 = create(2.0, 2.0)
let p3 = p1 .+. p2
printfn "%f" (gety p3)
```
#### 44.4. Параметризованные модули

Модуль может параметризоваться переменной типа, реализуя тем самым полиморфные типы, функции и значения.

Например, тип Очередь удобно реализовывать независимым от типов хранимых в очереди значений.

Сигнатура модуля может выглядеть так:
```
module Queue
type Queue<'a>
...
```
Реализация модуля:
```
module Queue
type Queue<'a> = {front: 'a list; rear: 'a list}
let empty = {front = []; rear = []}
...
```
Использование модуля:
```
let int_queue = Queue.empty : Queue.Queue<int>
...
```

### 45. ООП

#### 45.1. Аугментация типов

Аугментация типов позволяет уточнять типы параметров в перегружаемых операторах, чтобы избегать конфликтов типов.

Аугментация типов допускает определение типов в синтаксисе, больше похожем на стиль объектно-ориентированного программирования.

#### 45.2. ООП

F# поддерживает императивный и объектный стили кодирования, которыми не рекомендуется пользоваться без крайней необходимости.

Класс в F# определяется как аугментированный тип, где вместо определения типа задаётся функция-конструктор, внешне похожая на описание типа.

Класс - это тип, а значение такого типа называется объект.

Элементы класса внутри определения типа (класса) начинаются с ключевого слова member.

Статические элементы класса (которые "принадлежат" не объекту, а классу) начинаются с ключевых слов static member.

Пример класса Point:
```
type Point(X: float, Y: float) =
    member p.x = X
    member p.y = Y
    static member (+) (p1: Point, p2: Point) = Point(p1.x+p2.x, p1.y+p2.y)
 
let p1 = Point(1.0,1.0)
let p2 = Point(2.0,2.0)
let p3 = p1 + p2
printfn "%f %f" p3.x p3.y
```
В конструкторе можно использовать именованные аргументы, меняя их порядок.
```
let p1 = Point(Y=2.0, X=1.0) 
```

### 46. Императивное программирование

#### 46.1. Мутабельные переменные

Изменяемые переменные задаются с помощью ключевых слов let mutable.
```
let mutable x = 1 // x = 1
```
В дальнейшем значение переменной можно изменить (с учётом её типа) с помощью оператора присваивания <-.
```
x <- 7 // x = 7
```
Формально оператор <- выполняет некоторое вычисление, возвращая значение () типа unit.

В отличие от других операторов чистого функционального программирования оператор присваивания имеет побочный эффект: изменяется значение переменной, причём в результате вычисления <- это никак не отображается.

#### 446.2. Последовательная композиция

Оператор последовательной композиции ; комбинирует два выражения в одно.

Выражение
```
exp1 ; exp2
```
вычисляется так: сначала вычисляется выражение exp1 и его результат теряется; затем вычисляется выражение exp2, и его значение становится результатом композиции.
```
let x = 2
let y = x + 2 ; x - 2 // y = 0
```
Если первое выражение возвращает результат, тип которого отличен от unit, то компилятор выдаст предупреждение, которое можно отключить функцией ignore().
```
let y = ignore(x + 2); x - 2
```
Разделение выражений новыми строками эквивалентно применению оператора композиции.
```
exp1
exp2
```
#### 446.3. Мутабельные поля записей

В записях допускается создавать мутабельные поля, перед которыми указывается ключевое слово mutable.
```
type Cat = { name : string; age : int; sex: char; mutable food : int }

let eat (cat: Cat) = 
    cat.food <- cat.food + 10
    cat.food

let barsik = { name = "Barsik"; age = 5; sex = 'M'; food = 0 }
eat barsik // barsik.food = 10
```
#### 446.4. Ссылки

Запись - это значение, поэтому присвоить записи новую запись невозможно, допустимо лишь изменять её мутабельные поля.

В F# имеется тип ref, который упрощает работу с записями, состоящими из единственного мутабельного поля contents.

Оператор := имитирует императивное присваивание, заменяя в мутабельном поле contents левого аргумента его значение на правый аргумент.

Оператор ! извлекает содержимое поля contents.
```
let x = ref [1; 2; 3] // x : int list ref = {contents = [1;2;3];}
x := [3; 2; 1] // x : int list ref = {contents = [3;2;1];}
! x // [3; 2; 1]
```

### 47. Императивное программирование-2

#### 47.1. Цикл while

Команда
```
while условие do выражение 
```
вычисляет выражение до тех пор, пока условие истинно.

Результат работы while - значение () типа unit.
```
let x = ref 1
while ! x < 10 do
   x := ! x + 1
! x = 10 // true
```
#### 47.2. Императивные функции для работы с коллекциями

Функция List.iter применяет императивную функцию (первый параметр) к каждому элементу списка (второй параметр) и возвращает значение типа unit.

Главное в List.iter - это возможность использования побочных эффектов в императивной функции.
```
let mutable sum = 0
let f x = sum <- sum + x
List.iter f [2; 3; 5]
sum = 10 // 2+3+5
```
Функция List.iteri использует такие же параметры, как и функция List.iter, только при вызове императивной функции передаёт ей первым параметром индекс, последовательно увеличивающийся на единицу, начиная с 0, а очередной элемент списка поступает вторым параметром.
```
let mutable sum = 0
let f i x = sum <- sum + i * x
List.iteri f [1; 2; 3] 
sum = 8 // 0*1 + 1*2 + 2*3
```
#### 47.3. Массивы

Массивы (тип Array) - это своеобразный аналог списка фиксированного размера, элементы которого мутабельны (значения их могут изменяться).

Элементы массива заключаются в логические скобки [| |].
```
let arr = [| 1; 2; 3 |]
```
Для массива, как и для списка, можно задавать диапазоны.
```
let arr = [| 1 .. 10 |]
```
Доступ к конкретному элементу массива по его индексу выполняется с помощью индексатора .[ ] .
```
let arr = [| 1 .. 10 |]
let x = arr.[ 0 ]
arr.[ 0 ] <- x + 10
arr.[ 0 ] = 11 // true
```
Длина массива определяется функцией length.
```
Array.length(arr) = 10 // true
```
К значениям Array применены также изученные ранее функции ofList, toList, map, iter, iteri, fold, foldBack.

#### 47.4. Задания

47.4.1. Напишите функцию факториала f: int -> int, не используя рекурсию, с помощью императивных возможностей.

47.4.2. Напишите функцию fibo: int -> int, где fibo(n) вычисляет n-е число Фибоначчи (n >= 0), не используя рекурсию, с помощью императивных возможностей.
Последовательность Фибоначчи начинается с двух значений 0,1, а n-й элемент равен сумме n-1 - го и n-2 - го элементов: 0,1,1,2,3,5,8,13,...

Шаблон для отправки на сервер:
```
// 47.4.1
let f n = ...

// 47.4.2
let fibo n = ...
```
